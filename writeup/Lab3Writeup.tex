\documentclass[a4paper]{article}

\usepackage{fullpage} % Package to use full page
\usepackage{parskip} % Package to tweak paragraph skipping
\usepackage{tikz} % Package for drawing
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{siunitx}

\title{Lab 3\vspace{-4ex}}
\author{} %have blank author
\date{}	%have blank date

\begin{document}

\noindent
\large\textbf{Tiffany Yang} \\
\normalsize CS380L - Rossbach\\
April 2019{\vspace{-4ex}\\

%have title go below header
\begingroup
\let\newpage\relax
\maketitle
\endgroup

\section{Introduction}
% High-level description of the lab.
% Report how much time you spent on the lab.
% REMEMBER TO SUBMIT:
% - Makefile that generates 3 binaries: apager, dpager, and hpager
% - the code for your pagers
% - the code for the experiments
% - this report
% Describe how to run the stuff/ experiments!!

In order to run this code, please un-tar the tar, \verb|cd| into the top-level directory ("\verb|code/|"), and issue the command \verb|make|. This should create the 3 pagers (\verb|apager|, \verb|dpager|, and \verb|hpager|) along with the provided test programs. To run each test program with each pager 20 times, please enter the command

\begin{verbatim}
    $ python3 run_progs.py
\end{verbatim}

This python script processes the output of each program and prints the average for each data point of interest over the 20 iterations. The output of each iteration for a command will be saved in a text file corresponding to that command in the subdirectory \verb|results|.

If you would like to see the output mappings for each program as printed to stderr, please run them individually (i.e., without the python script).

%% DESCRIBE HOW TO RUN HYBRID HANDLER (but also just provide python script)
The interface to run \verb|hpager| is slightly different than that used to run the other two loaders. \verb|hpager| expects a command line argument that tells the pager which heuristic to use when demand paging. The argument corresponds to the number of pages the demand pager should attempt to load in with each page fault. For example:

\begin{verbatim}
    $ hpager 2 hello
\end{verbatim}
 
    will run the hybrid pager with a heuristic that maps in 2 pages on each fault. 

 
\section{System Setup}

\begin{table}[htb!]
    \begin{center}
    \begin{tabular}{| l | c | }
        \hline
            & \textit{Host} \\ \hline \hline
            \textbf{Processor} & Intel e5-2620 v4 @ 2.10GHz \\ \hline
            \textbf{CPU Cores} & 8\\ \hline
            \textbf{Memory} & 128 GB\\ \hline
            \textbf{OS} & Ubuntu 16.04.5 LTS \\ \hline
            \textbf{Kernel} & GNU/Linux 4.4.0-141-generic \\ \hline

            \textbf{Architecture} & x86\_64 \\ \hline
        \hline
    \end{tabular}
    \caption{Machine specifications}\label{specs}
    \end{center}
    \end{table}



\section{Linux Kernel Loader}
% Describe in pseudo-code the steps that occur in creating the memory image of a new process during execve.

\begin{verbatim}
create_mem_image {
    /* do_open_execat does the following */
    file = open_file(filename);
    validate_file(file);
    deny_write_access(file);  // prevent other processes from writing to binary
    fsnotify_open(file);  // notify the filesystem that this file has been opened
    
    do_scheduler_stuff(); // scheduler balancing
    
    /* fill in entries struct that holds info about binary being loaded */
    bprm->file = file;
    // do checks to determine what filename should be 
    bprm->filename = filename;  
    
    /* bprm_mm_init  does the following */
    bprm->mm = mm_alloc();  // allocate a new memory management struct
    save_current_stack_limit();
    
    bprm->vma = vm_area_alloc();  // create a virtual mem area for the stack
    
    vma_set_anonymous(); // mark region as anonoymous 
                         //(no need to do file mgmt when it's changed)
                    
    sema_down();  // lock the memory manager to write to it
    
    vma->vma_end = STACK_TOP_MAX;  // set the end of the stack's memory area to the 
                                   // largest possible stack address
    
    vma->vm_start  = vma->vm_end - PAGE_SIZE; // allocate a page to this memory area
    // set relevant stack flags
    // set the access permissions for this memory area
    
    insert_vm_struct(bprm->mm, bprm->vma);  // insert this vma into new process's mm
    
    // do architecture specific memory mgmt initialization
    
    bprm->p = vma->vm_end - sizeof(void *); // mark the top of the current top of mem
    
    /* prepare_arg_pages does the following */
    bprm->argc = count(argv);  // count ptrs in argv until nullptr reached
    bprm->envc = count(envp);  // count ptrs in envp until nullptr reached
    
    // limit size of argv + env strings to ensure that:
    //   - remaining binfmt code will not run out of stack space
    //   - the program has reasonable amount of stack to work from
    
    if (limit <= (size of all argv and enfp pointers)) return failure;
    
    // subtract the space taken up by those pointers from the max size limit
    bprm->argmin = bprm->p - limit;  // set min address where argument strings 
                                     // can start being copied       
                                     
    /* prepare_binprm does the following */
    bprm_fill_uid(bprm);  // fill in credentials for this bprm
    
    memset(bprm->buf, 0); // fill the buffer with 0s 
    read(bprm->file, bprm->buf); // read first 128 bytes from bin file into buffer
    
    copy_strings_kernel(1, &bprm->filename, bprm);  // copy filename from kernel mem 
                                                    // to bottom of stack
                                                 
    bprm->exec = bprm->p;  // set address of executable name to where filename
                           // was just copied
                           
    copy_strings(bprm->envc, envp, bprm);  // copy environment strings to stack
    
    copy_strings(bprm->argc, argv, bprm);  // copy argument strings to stack
    
    /* exec_binprm does the following */
    // search for the binary handler that matches this format
    
    // for elf:
    /* load_elf_binary does the following */
    loc->elf_ex = *(bprm->buf);  // get elf header
    
    // validate elf header
    
    elf_phdata = load_elf_phdrs();  // get the program headers from the file
    
    // go through program headers to find the interpreter
    
    for each program header {
        case (program header type):
            stack:
                // mark stack as executable or not based on flags
                
            PT_LOPROC through PT_HIPROC:
                // validate correctness of progream header
    } 
    
    // Perform consistency checks for the interpreter
    
    // Allow architecture-specific code to reject ELF
    
    flush_old_exec();  // flush all traces of currently running exec 
    
    // set personality flags for this executable
    // setup_new_exec by picking mmap layout, flushing signal handlers, etc.
    
    /* setup_arg_pages does the following  to finalize the vm_area_struct */
    
    // set and align the address to the top of the stack
    bprm->p -= stack_shift;  // adjust memory top to correspond to stack location shift
    mm->arg_start = bprm->p;  // set address where args will start
    
    bprm->exec -= stack_shift;  // move ptr to executable filename to account for stack shift
    
    // adjust stack execute permissions
    
    shift_arg_pages(vma, stack_shift);  // move the stack pages down in memory 
                                        // to correspond to current stack location
    stack_size = vma->vm_end - vma->vm_start;
    rlim_stack = rlim_stack & PAGE_MASK;  // align address down to page boundary
    
    // calculate the base of the stack
    
    for each program header {
        if (type != PT_LOAD) continue;
        
        if (elf_brk > elf_bss) {
            // There was a different program header of type PT_LOAD with 
            // a larger memsize than filesize (indicating BSS) before this one
            // Map anonymous pages and clear the area
            
            set_brk();  // map the last of the bss segment, move brk
            
            // zero bss
            
            elf_fixed = MAP_FIXED;  // forcefully map over newly established brk mapping
        }
        
        // Get protection flags for this mapping
        // Specify mmap flags for this mapping
        
        elf_map(bprm->file, flags, size); 
        
        // determine if address corresponds to start of text, data, or bss segment             
                
    }
    
    // Adjust all addresses for load_bias from dynamic loader
        
    set_brk();  // mmap pages for bss and break sections
        
    // load elf interpreter if interpreter is being used
        
    set_binfmt(&elf_format);  // set memory manager's binary handler to elf
    
    
    /* create_elf_tables does the following */
    
    p = arch_align_stack(p); // get pointer to the top of the stack
    
    // copy platform capability strings to current top of the stack
    
    get_random_bytes();  // generate 16 random bytes for userspace prng seeding
    copy_to_user(rand_bytes);  // copy random byte to user stack
    
    // create elf interpreter info
    
    ARCH_DLINFO;  // create architecture-specific aux vector entry
    
    // create the following auxiliary vector entries:
    // AT_HWCAP, AT_PAGESZ, AT_CLKTCK, AT_PHDR, AT_PHENT, AT_PHNUM, AT_BASE, 
    // AT_FLAGS, AT_ENTRY, AT_UID, AT_EUID, AT_GID, AT_EGID, AT_SECURE, 
    // AT_HWCAP2, AT_EXECFN, AT_PLATFORM
    
    memset(&elf_info[ei_index], 0);  // memset the AT_NULL entry to 0
    ei_index += 2;  // advance index past AT_NULL entry
    
    // point stack pointer to the lowest address on the stack
    // grow the stack
    
    // put argc on the stack
    
    for each argument starting from the last {
        put the corresponding pointer to this arg in the info block onto the stack
    }
    
    // put a 0 on the stack
    
    for each environment variable starting from the last {
        put a pointer to the corresponding env entry in the info block onto the stack
    }
    
    // put a 0 on the stack
    
    // copy the auxiliary vector to the stack
    
    // Start the new process
    
}

copy_strings {
    // for each argument in argv, beginning with the last 
    for (i = argc; argc > 0; i--) {
        str = get_arg(argv, i - 1); // get a pointer to this argument string
        
        // do validity checks on str length
        
        pos = bprm->p;  // determine the position to start writing to
        str += len;  // move string pointer to the back of the string
        bprm->p -= len;  // move the top of memory to account for copied arg
        
        // copy this argument to each correct page it belongs to
        while (len > 0) {
            // calculate offset into page to begin writing
            
            // calculate number of bytes to copy onto this page
            bytes_to_copy = (bytes_to_copy > len) ? len : offset;
            
            offset -= bytes_to_copy;
            pos -= bytes_to_copy;
            str -= bytes_to_copy; 
            len -= bytes_to_copy; 
            
            if (page not mapped or kpos changed) {
                // allocate page to or get page in the bprm->page array
                // flush the cache lines associated with this page
            }
            
            // Copy bytes_to_copy bytes of argument string beginning at address str
            copy_from_user(kaddr + offset, str, bytes_to_copy);
        }
        
        // flush the cache lines corresponding to the last copied page
    }
}    
\end{verbatim}

%/* copy_strings_kernel does the following */
%    // prepare to read from kernel mem instead of process mem
%   
%    // for each argument in argv, beginning with the last 
%    for (i = argc; argc > 0; i--) {
%        str = get_arg(argv, i - 1); // get a pointer to this argument string
%        
%        // do validity checks on str length
%        
%        pos = bprm->p;  // determine the position to start writing to
%        str += len;  // move string pointer to the back of the string
%        bprm->p -= len;  // move the top of memory to account for copied arg
%        
%        // copy this argument to each correct page it belongs to
%        while (len > 0) {
%            // calculate offset into page to begin writing
%            
%            // calculate number of bytes to copy onto this page
%            bytes_to_copy = (bytes_to_copy > len) ? len : offset;
%            
%            offset -= bytes_to_copy;
%            pos -= bytes_to_copy;
%            str -= bytes_to_copy; 
%            len -= bytes_to_copy; 
%            
%            if (page not mapped or kpos changed) {
%                // allocate page to or get page in the bprm->page array
%                // flush the cache lines associated with this page
%            }
%            
%            // Copy bytes_to_copy bytes of argument string beginning at address str
%            copy_from_user(kaddr + offset, str, bytes_to_copy);
%        }
%        
%        // flush the cache lines corresponding to the last copied page
%    }
%    
%    // Read from user mem from here on out
%    
%    copy_strings(bprm->   
%    
%}    


\section{All-at-once Pager}
\subsection{Implementation}
% Describe your implementation and challenges you faced.
The functionality of this loader is separated into several modules, \verb|loader_mem|, \verb|loader_elf|, \verb|loader_stack|, and \verb|loader|. The all-at-once pager first creates a new \verb|Loadee_mgmt| structure to hold the metadata for for the program being loaded in. This metadata includes a buffer into which the ELF header for the executable is read in, along with the start of the program's text segment, the base of its stack, a pointer to the top of its stack, the value of its entry point, its filename, and its file descriptor.

After initializing this structure, the ELF module is used to parse the ELF header for the executable to obtain the entry point and the lowest address of the program. The program headers are then iterated through and mapped using the memory module if they contain a segment of type \verb|PT_LOAD|. 

Next, the executable for the stack is set up by copying the information block from the loader to the loadee's stack, excluding the loader's \verb|argv[0]|. The address for each of these strings on the loadee's stack is recorded into a new \verb|argv| and \verb|envp| for the loadee that is later copied onto the loadee stack. Next, the auxiliary vector entries are populated by first copying the aux table from the loader to the loadee stack and then individually updating entries that are specified in the loadee's ELF header. The loadee's environment vector, argument vector, and number of arguments are then copied to its stack. Finally, inline assembly is used to clean up the registers, change the stack pointer to the top of the loadee's stack, and jump to the entry point of the loadee.


\subsection{Questions}
\textbf{What is different between running main and jmping to the entry point?}\\
\verb|jmp|ing to the entry point is different from calling \verb|main| because the entry point is the address of \verb|_start| for the loaded program. At \verb|_start|, all of the program's registers except for the stack pointer and instruction pointer are zeroed out. From \verb|_start| (which then calls \verb|__libc_start_main|, \verb|libc| sets up the registers, the stack, and other \verb|libc| specific features (e.g., threading ) before calling \verb|main|. This setup ensures that when the loaded program returns from \verb|main|, it returns to a \verb|libc| function that performs a system call to terminate the process. At the point where \verb|main| is called, \verb|libc| has populated all of the registers to contain the values that \verb|main| expects.

\verb|jmp| is different from \verb|call| because it jumps directly to the address provided as input. Conversely, \verb|call| saves the address to return to, jumps, and then returns to the caller.
        

\textbf{What happens if you try to run ./apager apager?}\\
If the program under test wants to load itself on top of the loader program, the loader prints a statement indicating so to \verb|stderr| and exits.
        
                    
\textbf{What happens when the program under test calls malloc?}\\
If the program under test calls malloc, a chunk of virtual memory is allocated to the process. This works because the loader and the loadee share a heap, so for small calls (less than \verb|MMAP_THRESHOLD| bytes), memory will be allocated from the heap. If the heap grows, then \verb|sbrk| will be used to increase the size of the heap to accommodate. If \verb|sbrk| fails (i.e., growing the heap would overlap with the loaded-in program), then \verb|malloc| looks for another hole in the memory to allocate from. For calls larger than the \verb|MMAP_THRESHOLD|, \verb|malloc| allocates memory as a private anonymous mapping, allowing the kernel to choose the starting address for the mapping (so that it does not collide with an existing mapping). 



\section{Demand Pager}
\subsection{Implementation}
% Describe your implementation and challenges you faced.
The demand loader is implemented similarly to all-at-once loader, except instead of mapping memory regions directly while parsing the ELF program headers, a linked list of \verb|Loadable_segment| structures is populated with the program header information that is necessary to create the mappings. A pointer to the head of this list can be accessed as a global variable within the demand pager. This allows the list to be passed in to the function call to map a memory page when the signal handler catches a \verb|SIGSEGV|. 

The signal handler was specified using \verb|sigaction| to be able to pass the faulting address to be mapped in. The relevant functions are specified in the \verb|loader_handler| function.

\subsection{Memory Access Errors}
\begin{verbatim}
        int main() {
            int *zero = NULL;
            return *zero;
        }
\end{verbatim}

% What does your demand pager do with this program? 
% What should it do? 
% Describe the method your demand pager used to preserve memory access errors present in the program under test.

\verb|dpager| demand loads several pages of this process until it tries to access memory at address 0. Since this value is not within the range of the addresses the loaded in process can access, the signal handler exits with an error code.

This behavior is implemented by maintaining the ranges of all of the mapped segments specified in the executable in \verb|Loadable_segment| structures. The signal handler checks the faulting address against each of the \verb|Loadable_segment|s belonging to the program under test. Any memory address within any of those ranges is mapped in. If the program attempts to access an address outside of any of those ranges, the program is terminated. Similarly, if the faulting address lies outside of the bounds of the start of the program's data segment and the base of its stack (which is the highest accessible address, as the stack grows down) it is terminated before checking the list of \verb|Loadable_segment|s. 

In order to observe how the behavior of this program, try running
\begin{verbatim}
    $ ./dpager nullprog
\end{verbatim}

\section{Hybrid Pager}
% Explain the heuristics you use to implement the hybrid loader.

For the hybrid pager, when a memory exception occurs using the two-page loading heuristics, the loader first checks whether the page after the faulting page is mapped. This check is performed by calling \verb|mincore| on the next page in memory and then checking the \verb|errno| to ensure that \verb|mincore| failed because the address contained unmapped memory. If the subsequent page is not mapped, the two pages beginning at the faulting address are mapped into memory. If it is mapped, the same check is performed for the page preceding the faulting address. If the preceding page is not mapped, then a contiguous mapping is created beginning on the page before the faulting address.

If both the previous and the subsequent pages are already mapped, the faulting page is mapped in, and then the handler searches for another page within the bss that has not yet been mapped. Currently, the algorithm searches the next 10 pages before returning. If no unmapped page is found, the signal handler returns at this point (since the performance cost of looking for an additional page to map in will begin to outweigh the benefit of avoiding a future fault on a discontiguous address). 

 The heuristics used for mapping in two pages differs slightly from those used for mapping in three. When searching for a third page to map in, the algorithm only looks at the two pages that follow the page of the faulting address. If both of them are unmapped, the handler creates a 3-page mapping beginning with the faulting page. If only the following page is unmapped, the handler creates a 2-page mapping beginning with the faulting page. Unlike the 2-page heuristics, the 3-page heuristics do not look for a contiguous unmapped region that begins before the faulting address. Instead, the handler looks for the next unmapped address and attempts to map the page that comes after it.

\section{Tests}
% Describe the at least two test programs that your loaders will load and execute. 
% Describe what functionality of your loaders your test programs exercise. 
% Hypothesize about their execution time and memory use on the different loaders.
The four programs under test are \verb|stack_examiner|, \verb|readmap|, \verb|lessmem|, and \verb|fastmem|. Stack examiner simply examines the values on the program's stack (including the environment variables and aux table entries) and prints the values to stdout. The output of this program when loaded by the loader can be compared to its output when running directly from the terminal to ensure that the loader is correctly setting up the stack. \verb|readmap| prints the contents of the program's \verb|/proc/self/maps| file to stdout after several memory allocations. It then calls \verb|malloc| to allocate a small region and then \verb|malloc|s a very large region to allow the user to see how the memory mappings for the process change after each allocation. 

\verb|lessmem| and \verb|fastmem| are two programs created specifically to test how the all-at-once pager behaves compared to the other pagers in the subsequent parts of this lab. Both declare a global int array of 102400 entries (100 pages). \verb|fastmem| accesses one entry on each page of the array and sets it equal to the number page it corresponds to (beginning at 0.  \verb|lessmem| accesses one entry in the array and changes its value. These two programs are meant to demonstrate how the access patterns of the same array can impact the performance of each loader.

Together, all of these programs ensure that the loader correctly loads the programs underneath and does not interfere with memory allocation after the program has been loaded.



\section{Results}
% Present the execution time and memory usage of the tests when they are run by your loader.
The execution time reported for each of these pager-test program combinations is calculated by calling \verb|getrusage| at the beginning and end of each test program. The system time and user time are both summed to obtain the total execution time for the program. We report the difference between times returned in the \verb|struct getrusage| at the beginning and end of the program. The memory usage reported for each test program is obtained by parsing \verb|/proc/self/statm| and reading the column corresponding to the total program size. According to the documentation, this value specifies information about memory usage measured in pages.

\subsection{All-at-once vs. Demand Pager}

The execution times for each of the test programs under the demand and paging loader are provided in \ref{fig:adtime}. The execution time for each of the test programs is smaller under \verb|apager| than \verb|dpager|, though \verb|fastmem| represents the workload with the most similar execution times, since the process itself is fairly small, and only accesses one value inside of the allocated array.

\begin{figure}[htbp!]
\centering
\includegraphics[width=.65\textwidth]{{ADTime}.png}
\caption{Execution time of the all-at-once and demand pagers on different tests}
\label{fig:adtime}
\end{figure} 

The memory usage for each of the test programs except for \verb|readmap| are provided in \ref{fig:adsize}. The memory size of \verb|readmap| is left off of the plot for both \verb|apager| and \verb|dpager| because for both loaders, memory usage was several orders of magnitude larger than for any of the other test programs. For \verb|apager|, the memory used for \verb|readmap| was 1049135 pages and that for \verb|dpager| was 1049005.15 pages, on average. This ballooning in memory usage is due to the fact that \verb|readmap| allocates a several GB-size buffer using \verb|malloc|.

As indicated in \ref{fig:adsize}, the memory usage of all of the test programs is less under \verb|dpager| than under \verb|apager|.

\begin{figure}[htbp!]
\centering
\includegraphics[width=.65\textwidth]{{ADTotalSize}.png}
\caption{Memory usage of the all-at-once and demand pagers on different tests}
\label{fig:adsize}
\end{figure}


% Demonstrate at least one program that runs faster for the all-at-once loader, and one that uses less memory for the demand paging loader.
\subsection{Hybrid Pager}
% Find a workload that runs faster on the hybrid pager with your prediction algorithm than without and explain why.

While the execution time for \verb|stack_examiner|, \verb|lessmem|, and \verb|readmap| seem to be relatively constant regardless of the specified heuristic, \verb|fastmem| indicates significant performance improvements when using a prediction algorithm to map in additional pages. This improvement is a result of the pattern used to access the global array in \verb|fastmem|. Since each page in the array is accessed sequentially, mapping in several pages at a time causes fewer segmentation faults, thereby allowing the process to spend less time in the signal handler over the duration of the program. The time-savings when mapping in 3 consecutive pages instead of 2 are less substantial than those achieved by mapping in 2 pages instead of 1, but they still indicate a significant improvement.

\begin{figure}[htbp!]
\centering
\includegraphics[width=.65\textwidth]{{HybridTime}.png}
\caption{Execution time of the test programs under different paging heuristics}
\label{fig:htime}
\end{figure} 

Similarly to the experiments for \verb|apager| and \verb|dpager|, the memory usage by one of the calls to \verb|malloc| in \verb|readmap| is so large that it would require a different axis than the other test programs in \ref{fig:hsize}. The graphs indicate that changing the heuristic used in the  hybrid loader does not appear to have a significant effect on the program size.

\begin{figure}[htbp!]
\centering
\includegraphics[width=.65\textwidth]{{HybridSize}.png}
\caption{Memory usage of the test programs under different paging heuristics}
\label{fig:hsize}
\end{figure}
% Present the results of mapping 3 pages instead of 2 in the hybrid pager and compare to "whatever is most illuminating".


\section{Time Spent}

I spent about 80 hours on this lab.

\end{document}